import W,{PROPOSAL_EXPIRY_MESSAGE as X}from"@walletconnect/sign-client";import{isValidObject as Y,isCaipNamespace as N,parseNamespaceKey as P,mergeArrays as H,parseChainId as y,getSdkError as O,isValidArray as q}from"@walletconnect/utils";import{pino as K,getDefaultLoggerOptions as Q}from"@walletconnect/logger";import{merge as Z}from"lodash";import u,{HttpConnection as tt}from"@walletconnect/jsonrpc-http-connection";import{JsonRpcProvider as d}from"@walletconnect/jsonrpc-provider";import{formatJsonRpcRequest as et,formatJsonRpcResult as st}from"@walletconnect/jsonrpc-utils";import it from"events";const D="error",rt="wss://relay.walletconnect.org",nt="wc",at="universal_provider",S=`${nt}@2:${at}:`,_="https://rpc.walletconnect.org/v1/",f="generic",ot=`${_}bundler`,p={DEFAULT_CHAIN_CHANGED:"default_chain_changed"};var ct=Object.defineProperty,ht=Object.defineProperties,pt=Object.getOwnPropertyDescriptors,j=Object.getOwnPropertySymbols,dt=Object.prototype.hasOwnProperty,ut=Object.prototype.propertyIsEnumerable,R=(r,t,e)=>t in r?ct(r,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):r[t]=e,g=(r,t)=>{for(var e in t||(t={}))dt.call(t,e)&&R(r,e,t[e]);if(j)for(var e of j(t))ut.call(t,e)&&R(r,e,t[e]);return r},lt=(r,t)=>ht(r,pt(t));function h(r,t,e){var s;const i=y(r);return((s=t.rpcMap)==null?void 0:s[i.reference])||`${_}?chainId=${i.namespace}:${i.reference}&projectId=${e}`}function l(r){return r.includes(":")?r.split(":")[1]:r}function U(r){return r.map(t=>`${t.split(":")[0]}:${t.split(":")[1]}`)}function mt(r,t){const e=Object.keys(t.namespaces).filter(i=>i.includes(r));if(!e.length)return[];const s=[];return e.forEach(i=>{const n=t.namespaces[i].accounts;s.push(...n)}),s}function $(r={},t={}){const e=T(r),s=T(t);return Z(e,s)}function T(r){var t,e,s,i;const n={};if(!Y(r))return n;for(const[a,c]of Object.entries(r)){const m=N(a)?[a]:c.chains,I=c.methods||[],V=c.events||[],B=c.rpcMap||{},v=P(a);n[v]=lt(g(g({},n[v]),c),{chains:H(m,(t=n[v])==null?void 0:t.chains),methods:H(I,(e=n[v])==null?void 0:e.methods),events:H(V,(s=n[v])==null?void 0:s.events),rpcMap:g(g({},B),(i=n[v])==null?void 0:i.rpcMap)})}return n}function vt(r){return r.includes(":")?r.split(":")[2]:r}function k(r){const t={};for(const[e,s]of Object.entries(r)){const i=s.methods||[],n=s.events||[],a=s.accounts||[],c=N(e)?[e]:s.chains?s.chains:U(s.accounts);t[e]={chains:c,methods:i,events:n,accounts:a}}return t}function E(r){return typeof r=="number"?r:r.includes("0x")?parseInt(r,16):(r=r.includes(":")?r.split(":")[1]:r,isNaN(Number(r))?r:Number(r))}const L={},o=r=>L[r],b=(r,t)=>{L[r]=t};class ft{constructor(t){this.name="polkadot",this.namespace=t.namespace,this.events=o("events"),this.client=o("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error("ChainId not found");return t.split(":")[1]}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider().request(t.request)}setDefaultChain(t,e){this.httpProviders[t]||this.setHttpProvider(t,e),this.chainId=t,this.events.emit(p.DEFAULT_CHAIN_CHANGED,`${this.name}:${t}`)}getAccounts(){const t=this.namespace.accounts;return t?t.filter(e=>e.split(":")[1]===this.chainId.toString()).map(e=>e.split(":")[2])||[]:[]}createHttpProviders(){const t={};return this.namespace.chains.forEach(e=>{var s;const i=l(e);t[i]=this.createHttpProvider(i,(s=this.namespace.rpcMap)==null?void 0:s[e])}),t}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>"u")throw new Error(`JSON-RPC provider for ${t} not found`);return e}setHttpProvider(t,e){const s=this.createHttpProvider(t,e);s&&(this.httpProviders[t]=s)}createHttpProvider(t,e){const s=e||h(t,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${t}`);return new d(new u(s,o("disableProviderPing")))}}var Pt=Object.defineProperty,gt=Object.defineProperties,wt=Object.getOwnPropertyDescriptors,F=Object.getOwnPropertySymbols,Ct=Object.prototype.hasOwnProperty,It=Object.prototype.propertyIsEnumerable,G=(r,t,e)=>t in r?Pt(r,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):r[t]=e,M=(r,t)=>{for(var e in t||(t={}))Ct.call(t,e)&&G(r,e,t[e]);if(F)for(var e of F(t))It.call(t,e)&&G(r,e,t[e]);return r},x=(r,t)=>gt(r,wt(t));class Ht{constructor(t){this.name="eip155",this.namespace=t.namespace,this.events=o("events"),this.client=o("client"),this.httpProviders=this.createHttpProviders(),this.chainId=parseInt(this.getDefaultChain())}async request(t){switch(t.request.method){case"eth_requestAccounts":return this.getAccounts();case"eth_accounts":return this.getAccounts();case"wallet_switchEthereumChain":return await this.handleSwitchChain(t);case"eth_chainId":return parseInt(this.getDefaultChain());case"wallet_getCapabilities":return await this.getCapabilities(t);case"wallet_getCallsStatus":return await this.getCallStatus(t)}return this.namespace.methods.includes(t.request.method)?await this.client.request(t):this.getHttpProvider().request(t.request)}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}setDefaultChain(t,e){this.httpProviders[t]||this.setHttpProvider(parseInt(t),e),this.chainId=parseInt(t),this.events.emit(p.DEFAULT_CHAIN_CHANGED,`${this.name}:${t}`)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId.toString();if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error("ChainId not found");return t.split(":")[1]}createHttpProvider(t,e){const s=e||h(`${this.name}:${t}`,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${t}`);return new d(new tt(s,o("disableProviderPing")))}setHttpProvider(t,e){const s=this.createHttpProvider(t,e);s&&(this.httpProviders[t]=s)}createHttpProviders(){const t={};return this.namespace.chains.forEach(e=>{var s;const i=parseInt(l(e));t[i]=this.createHttpProvider(i,(s=this.namespace.rpcMap)==null?void 0:s[e])}),t}getAccounts(){const t=this.namespace.accounts;return t?[...new Set(t.filter(e=>e.split(":")[1]===this.chainId.toString()).map(e=>e.split(":")[2]))]:[]}getHttpProvider(){const t=this.chainId,e=this.httpProviders[t];if(typeof e>"u")throw new Error(`JSON-RPC provider for ${t} not found`);return e}async handleSwitchChain(t){var e,s;let i=t.request.params?(e=t.request.params[0])==null?void 0:e.chainId:"0x0";i=i.startsWith("0x")?i:`0x${i}`;const n=parseInt(i,16);if(this.isChainApproved(n))this.setDefaultChain(`${n}`);else if(this.namespace.methods.includes("wallet_switchEthereumChain"))await this.client.request({topic:t.topic,request:{method:t.request.method,params:[{chainId:i}]},chainId:(s=this.namespace.chains)==null?void 0:s[0]}),this.setDefaultChain(`${n}`);else throw new Error(`Failed to switch to chain 'eip155:${n}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);return null}isChainApproved(t){return this.namespace.chains.includes(`${this.name}:${t}`)}async getCapabilities(t){var e,s,i;const n=(s=(e=t.request)==null?void 0:e.params)==null?void 0:s[0];if(!n)throw new Error("Missing address parameter in `wallet_getCapabilities` request");const a=this.client.session.get(t.topic),c=((i=a?.sessionProperties)==null?void 0:i.capabilities)||{};if(c!=null&&c[n])return c?.[n];const m=await this.client.request(t);try{await this.client.session.update(t.topic,{sessionProperties:x(M({},a.sessionProperties||{}),{capabilities:x(M({},c||{}),{[n]:m})})})}catch(I){console.warn("Failed to update session with capabilities",I)}return m}async getCallStatus(t){var e,s;const i=this.client.session.get(t.topic),n=(e=i.sessionProperties)==null?void 0:e.bundler_name;if(n){const c=this.getBundlerUrl(t.chainId,n);try{return await this.getUserOperationReceipt(c,t)}catch(m){console.warn("Failed to fetch call status from bundler",m,c)}}const a=(s=i.sessionProperties)==null?void 0:s.bundler_url;if(a)try{return await this.getUserOperationReceipt(a,t)}catch(c){console.warn("Failed to fetch call status from custom bundler",c,a)}if(this.namespace.methods.includes(t.request.method))return await this.client.request(t);throw new Error("Fetching call status not approved by the wallet.")}async getUserOperationReceipt(t,e){var s;const i=new URL(t),n=await fetch(i,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(et("eth_getUserOperationReceipt",[(s=e.request.params)==null?void 0:s[0]]))});if(!n.ok)throw new Error(`Failed to fetch user operation receipt - ${n.status}`);return await n.json()}getBundlerUrl(t,e){return`${ot}?projectId=${this.client.core.projectId}&chainId=${t}&bundler=${e}`}}class $t{constructor(t){this.name="solana",this.namespace=t.namespace,this.events=o("events"),this.client=o("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}requestAccounts(){return this.getAccounts()}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider().request(t.request)}setDefaultChain(t,e){this.httpProviders[t]||this.setHttpProvider(t,e),this.chainId=t,this.events.emit(p.DEFAULT_CHAIN_CHANGED,`${this.name}:${t}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error("ChainId not found");return t.split(":")[1]}getAccounts(){const t=this.namespace.accounts;return t?[...new Set(t.filter(e=>e.split(":")[1]===this.chainId.toString()).map(e=>e.split(":")[2]))]:[]}createHttpProviders(){const t={};return this.namespace.chains.forEach(e=>{var s;const i=l(e);t[i]=this.createHttpProvider(i,(s=this.namespace.rpcMap)==null?void 0:s[e])}),t}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>"u")throw new Error(`JSON-RPC provider for ${t} not found`);return e}setHttpProvider(t,e){const s=this.createHttpProvider(t,e);s&&(this.httpProviders[t]=s)}createHttpProvider(t,e){const s=e||h(t,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${t}`);return new d(new u(s,o("disableProviderPing")))}}class Et{constructor(t){this.name="cosmos",this.namespace=t.namespace,this.events=o("events"),this.client=o("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error("ChainId not found");return t.split(":")[1]}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider().request(t.request)}setDefaultChain(t,e){this.httpProviders[t]||this.setHttpProvider(t,e),this.chainId=t,this.events.emit(p.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getAccounts(){const t=this.namespace.accounts;return t?[...new Set(t.filter(e=>e.split(":")[1]===this.chainId.toString()).map(e=>e.split(":")[2]))]:[]}createHttpProviders(){const t={};return this.namespace.chains.forEach(e=>{var s;const i=l(e);t[i]=this.createHttpProvider(i,(s=this.namespace.rpcMap)==null?void 0:s[e])}),t}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>"u")throw new Error(`JSON-RPC provider for ${t} not found`);return e}setHttpProvider(t,e){const s=this.createHttpProvider(t,e);s&&(this.httpProviders[t]=s)}createHttpProvider(t,e){const s=e||h(t,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${t}`);return new d(new u(s,o("disableProviderPing")))}}class bt{constructor(t){this.name="algorand",this.namespace=t.namespace,this.events=o("events"),this.client=o("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}requestAccounts(){return this.getAccounts()}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider().request(t.request)}setDefaultChain(t,e){if(!this.httpProviders[t]){const s=e||h(`${this.name}:${t}`,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${t}`);this.setHttpProvider(t,s)}this.chainId=t,this.events.emit(p.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error("ChainId not found");return t.split(":")[1]}getAccounts(){const t=this.namespace.accounts;return t?[...new Set(t.filter(e=>e.split(":")[1]===this.chainId.toString()).map(e=>e.split(":")[2]))]:[]}createHttpProviders(){const t={};return this.namespace.chains.forEach(e=>{var s;t[e]=this.createHttpProvider(e,(s=this.namespace.rpcMap)==null?void 0:s[e])}),t}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>"u")throw new Error(`JSON-RPC provider for ${t} not found`);return e}setHttpProvider(t,e){const s=this.createHttpProvider(t,e);s&&(this.httpProviders[t]=s)}createHttpProvider(t,e){const s=e||h(t,this.namespace,this.client.core.projectId);return typeof s>"u"?void 0:new d(new u(s,o("disableProviderPing")))}}class At{constructor(t){this.name="cip34",this.namespace=t.namespace,this.events=o("events"),this.client=o("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error("ChainId not found");return t.split(":")[1]}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider().request(t.request)}setDefaultChain(t,e){this.httpProviders[t]||this.setHttpProvider(t,e),this.chainId=t,this.events.emit(p.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getAccounts(){const t=this.namespace.accounts;return t?[...new Set(t.filter(e=>e.split(":")[1]===this.chainId.toString()).map(e=>e.split(":")[2]))]:[]}createHttpProviders(){const t={};return this.namespace.chains.forEach(e=>{const s=this.getCardanoRPCUrl(e),i=l(e);t[i]=this.createHttpProvider(i,s)}),t}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>"u")throw new Error(`JSON-RPC provider for ${t} not found`);return e}getCardanoRPCUrl(t){const e=this.namespace.rpcMap;if(e)return e[t]}setHttpProvider(t,e){const s=this.createHttpProvider(t,e);s&&(this.httpProviders[t]=s)}createHttpProvider(t,e){const s=e||this.getCardanoRPCUrl(t);if(!s)throw new Error(`No RPC url provided for chainId: ${t}`);return new d(new u(s,o("disableProviderPing")))}}class Nt{constructor(t){this.name="elrond",this.namespace=t.namespace,this.events=o("events"),this.client=o("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}requestAccounts(){return this.getAccounts()}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider().request(t.request)}setDefaultChain(t,e){this.httpProviders[t]||this.setHttpProvider(t,e),this.chainId=t,this.events.emit(p.DEFAULT_CHAIN_CHANGED,`${this.name}:${t}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error("ChainId not found");return t.split(":")[1]}getAccounts(){const t=this.namespace.accounts;return t?[...new Set(t.filter(e=>e.split(":")[1]===this.chainId.toString()).map(e=>e.split(":")[2]))]:[]}createHttpProviders(){const t={};return this.namespace.chains.forEach(e=>{var s;const i=l(e);t[i]=this.createHttpProvider(i,(s=this.namespace.rpcMap)==null?void 0:s[e])}),t}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>"u")throw new Error(`JSON-RPC provider for ${t} not found`);return e}setHttpProvider(t,e){const s=this.createHttpProvider(t,e);s&&(this.httpProviders[t]=s)}createHttpProvider(t,e){const s=e||h(t,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${t}`);return new d(new u(s,o("disableProviderPing")))}}class yt{constructor(t){this.name="multiversx",this.namespace=t.namespace,this.events=o("events"),this.client=o("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}requestAccounts(){return this.getAccounts()}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider().request(t.request)}setDefaultChain(t,e){this.httpProviders[t]||this.setHttpProvider(t,e),this.chainId=t,this.events.emit(p.DEFAULT_CHAIN_CHANGED,`${this.name}:${t}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error("ChainId not found");return t.split(":")[1]}getAccounts(){const t=this.namespace.accounts;return t?[...new Set(t.filter(e=>e.split(":")[1]===this.chainId.toString()).map(e=>e.split(":")[2]))]:[]}createHttpProviders(){const t={};return this.namespace.chains.forEach(e=>{var s;const i=l(e);t[i]=this.createHttpProvider(i,(s=this.namespace.rpcMap)==null?void 0:s[e])}),t}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>"u")throw new Error(`JSON-RPC provider for ${t} not found`);return e}setHttpProvider(t,e){const s=this.createHttpProvider(t,e);s&&(this.httpProviders[t]=s)}createHttpProvider(t,e){const s=e||h(t,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${t}`);return new d(new u(s,o("disableProviderPing")))}}class Ot{constructor(t){this.name="near",this.namespace=t.namespace,this.events=o("events"),this.client=o("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error("ChainId not found");return t.split(":")[1]}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider().request(t.request)}setDefaultChain(t,e){if(this.chainId=t,!this.httpProviders[t]){const s=e||h(`${this.name}:${t}`,this.namespace);if(!s)throw new Error(`No RPC url provided for chainId: ${t}`);this.setHttpProvider(t,s)}this.events.emit(p.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getAccounts(){const t=this.namespace.accounts;return t?t.filter(e=>e.split(":")[1]===this.chainId.toString()).map(e=>e.split(":")[2])||[]:[]}createHttpProviders(){const t={};return this.namespace.chains.forEach(e=>{var s;t[e]=this.createHttpProvider(e,(s=this.namespace.rpcMap)==null?void 0:s[e])}),t}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>"u")throw new Error(`JSON-RPC provider for ${t} not found`);return e}setHttpProvider(t,e){const s=this.createHttpProvider(t,e);s&&(this.httpProviders[t]=s)}createHttpProvider(t,e){const s=e||h(t,this.namespace);return typeof s>"u"?void 0:new d(new u(s,o("disableProviderPing")))}}class qt{constructor(t){this.name="tezos",this.namespace=t.namespace,this.events=o("events"),this.client=o("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace=Object.assign(this.namespace,t)}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error("ChainId not found");return t.split(":")[1]}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider().request(t.request)}setDefaultChain(t,e){if(this.chainId=t,!this.httpProviders[t]){const s=e||h(`${this.name}:${t}`,this.namespace);if(!s)throw new Error(`No RPC url provided for chainId: ${t}`);this.setHttpProvider(t,s)}this.events.emit(p.DEFAULT_CHAIN_CHANGED,`${this.name}:${this.chainId}`)}getAccounts(){const t=this.namespace.accounts;return t?t.filter(e=>e.split(":")[1]===this.chainId.toString()).map(e=>e.split(":")[2])||[]:[]}createHttpProviders(){const t={};return this.namespace.chains.forEach(e=>{t[e]=this.createHttpProvider(e)}),t}getHttpProvider(){const t=`${this.name}:${this.chainId}`,e=this.httpProviders[t];if(typeof e>"u")throw new Error(`JSON-RPC provider for ${t} not found`);return e}setHttpProvider(t,e){const s=this.createHttpProvider(t,e);s&&(this.httpProviders[t]=s)}createHttpProvider(t,e){const s=e||h(t,this.namespace);return typeof s>"u"?void 0:new d(new u(s))}}class Dt{constructor(t){this.name=f,this.namespace=t.namespace,this.events=o("events"),this.client=o("client"),this.chainId=this.getDefaultChain(),this.httpProviders=this.createHttpProviders()}updateNamespace(t){this.namespace.chains=[...new Set((this.namespace.chains||[]).concat(t.chains||[]))],this.namespace.accounts=[...new Set((this.namespace.accounts||[]).concat(t.accounts||[]))],this.namespace.methods=[...new Set((this.namespace.methods||[]).concat(t.methods||[]))],this.namespace.events=[...new Set((this.namespace.events||[]).concat(t.events||[]))],this.httpProviders=this.createHttpProviders()}requestAccounts(){return this.getAccounts()}request(t){return this.namespace.methods.includes(t.request.method)?this.client.request(t):this.getHttpProvider(t.chainId).request(t.request)}setDefaultChain(t,e){this.httpProviders[t]||this.setHttpProvider(t,e),this.chainId=t,this.events.emit(p.DEFAULT_CHAIN_CHANGED,`${this.name}:${t}`)}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const t=this.namespace.chains[0];if(!t)throw new Error("ChainId not found");return t.split(":")[1]}getAccounts(){const t=this.namespace.accounts;return t?[...new Set(t.filter(e=>e.split(":")[1]===this.chainId.toString()).map(e=>e.split(":")[2]))]:[]}createHttpProviders(){var t,e;const s={};return(e=(t=this.namespace)==null?void 0:t.accounts)==null||e.forEach(i=>{const n=y(i);s[`${n.namespace}:${n.reference}`]=this.createHttpProvider(i)}),s}getHttpProvider(t){const e=this.httpProviders[t];if(typeof e>"u")throw new Error(`JSON-RPC provider for ${t} not found`);return e}setHttpProvider(t,e){const s=this.createHttpProvider(t,e);s&&(this.httpProviders[t]=s)}createHttpProvider(t,e){const s=e||h(t,this.namespace,this.client.core.projectId);if(!s)throw new Error(`No RPC url provided for chainId: ${t}`);return new d(new u(s,o("disableProviderPing")))}}var St=Object.defineProperty,_t=Object.defineProperties,jt=Object.getOwnPropertyDescriptors,J=Object.getOwnPropertySymbols,Rt=Object.prototype.hasOwnProperty,Ut=Object.prototype.propertyIsEnumerable,z=(r,t,e)=>t in r?St(r,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):r[t]=e,w=(r,t)=>{for(var e in t||(t={}))Rt.call(t,e)&&z(r,e,t[e]);if(J)for(var e of J(t))Ut.call(t,e)&&z(r,e,t[e]);return r},A=(r,t)=>_t(r,jt(t));class C{constructor(t){this.events=new it,this.rpcProviders={},this.shouldAbortPairingAttempt=!1,this.maxPairingAttempts=10,this.disableProviderPing=!1,this.providerOpts=t,this.logger=typeof t?.logger<"u"&&typeof t?.logger!="string"?t.logger:K(Q({level:t?.logger||D})),this.disableProviderPing=t?.disableProviderPing||!1}static async init(t){const e=new C(t);return await e.initialize(),e}async request(t,e,s){const[i,n]=this.validateChain(e);if(!this.session)throw new Error("Please call connect() before request()");return await this.getProvider(i).request({request:w({},t),chainId:`${i}:${n}`,topic:this.session.topic,expiry:s})}sendAsync(t,e,s,i){const n=new Date().getTime();this.request(t,s,i).then(a=>e(null,st(n,a))).catch(a=>e(a,void 0))}async enable(){if(!this.client)throw new Error("Sign Client not initialized");return this.session||await this.connect({namespaces:this.namespaces,optionalNamespaces:this.optionalNamespaces,sessionProperties:this.sessionProperties}),await this.requestAccounts()}async disconnect(){var t;if(!this.session)throw new Error("Please call connect() before enable()");await this.client.disconnect({topic:(t=this.session)==null?void 0:t.topic,reason:O("USER_DISCONNECTED")}),await this.cleanup()}async connect(t){if(!this.client)throw new Error("Sign Client not initialized");if(this.setNamespaces(t),await this.cleanupPendingPairings(),!t.skipPairing)return await this.pair(t.pairingTopic)}async authenticate(t,e){if(!this.client)throw new Error("Sign Client not initialized");this.setNamespaces(t),await this.cleanupPendingPairings();const{uri:s,response:i}=await this.client.authenticate(t,e);s&&(this.uri=s,this.events.emit("display_uri",s));const n=await i();if(this.session=n.session,this.session){const a=k(this.session.namespaces);this.namespaces=$(this.namespaces,a),this.persist("namespaces",this.namespaces),this.onConnect()}return n}on(t,e){this.events.on(t,e)}once(t,e){this.events.once(t,e)}removeListener(t,e){this.events.removeListener(t,e)}off(t,e){this.events.off(t,e)}get isWalletConnect(){return!0}async pair(t){this.shouldAbortPairingAttempt=!1;let e=0;do{if(this.shouldAbortPairingAttempt)throw new Error("Pairing aborted");if(e>=this.maxPairingAttempts)throw new Error("Max auto pairing attempts reached");const{uri:s,approval:i}=await this.client.connect({pairingTopic:t,requiredNamespaces:this.namespaces,optionalNamespaces:this.optionalNamespaces,sessionProperties:this.sessionProperties});s&&(this.uri=s,this.events.emit("display_uri",s)),await i().then(n=>{this.session=n;const a=k(n.namespaces);this.namespaces=$(this.namespaces,a),this.persist("namespaces",this.namespaces)}).catch(n=>{if(n.message!==X)throw n;e++})}while(!this.session);return this.onConnect(),this.session}setDefaultChain(t,e){try{if(!this.session)return;const[s,i]=this.validateChain(t),n=this.getProvider(s);n.name===f?n.setDefaultChain(`${s}:${i}`,e):n.setDefaultChain(i,e)}catch(s){if(!/Please call connect/.test(s.message))throw s}}async cleanupPendingPairings(t={}){this.logger.info("Cleaning up inactive pairings...");const e=this.client.pairing.getAll();if(q(e)){for(const s of e)t.deletePairings?this.client.core.expirer.set(s.topic,0):await this.client.core.relayer.subscriber.unsubscribe(s.topic);this.logger.info(`Inactive pairings cleared: ${e.length}`)}}abortPairingAttempt(){this.shouldAbortPairingAttempt=!0}async checkStorage(){if(this.namespaces=await this.getFromStore("namespaces"),this.optionalNamespaces=await this.getFromStore("optionalNamespaces")||{},this.client.session.length){const t=this.client.session.keys.length-1;this.session=this.client.session.get(this.client.session.keys[t]),this.createProviders()}}async initialize(){this.logger.trace("Initialized"),await this.createClient(),await this.checkStorage(),this.registerEventListeners()}async createClient(){this.client=this.providerOpts.client||await W.init({core:this.providerOpts.core,logger:this.providerOpts.logger||D,relayUrl:this.providerOpts.relayUrl||rt,projectId:this.providerOpts.projectId,metadata:this.providerOpts.metadata,storageOptions:this.providerOpts.storageOptions,storage:this.providerOpts.storage,name:this.providerOpts.name,customStoragePrefix:this.providerOpts.customStoragePrefix,telemetryEnabled:this.providerOpts.telemetryEnabled}),this.logger.trace("SignClient Initialized")}createProviders(){if(!this.client)throw new Error("Sign Client not initialized");if(!this.session)throw new Error("Session not initialized. Please call connect() before enable()");const t=[...new Set(Object.keys(this.session.namespaces).map(e=>P(e)))];b("client",this.client),b("events",this.events),b("disableProviderPing",this.disableProviderPing),t.forEach(e=>{if(!this.session)return;const s=mt(e,this.session),i=U(s),n=$(this.namespaces,this.optionalNamespaces),a=A(w({},n[e]),{accounts:s,chains:i});switch(e){case"eip155":this.rpcProviders[e]=new Ht({namespace:a});break;case"algorand":this.rpcProviders[e]=new bt({namespace:a});break;case"solana":this.rpcProviders[e]=new $t({namespace:a});break;case"cosmos":this.rpcProviders[e]=new Et({namespace:a});break;case"polkadot":this.rpcProviders[e]=new ft({namespace:a});break;case"cip34":this.rpcProviders[e]=new At({namespace:a});break;case"elrond":this.rpcProviders[e]=new Nt({namespace:a});break;case"multiversx":this.rpcProviders[e]=new yt({namespace:a});break;case"near":this.rpcProviders[e]=new Ot({namespace:a});break;case"tezos":this.rpcProviders[e]=new qt({namespace:a});break;default:this.rpcProviders[f]?this.rpcProviders[f].updateNamespace(a):this.rpcProviders[f]=new Dt({namespace:a})}})}registerEventListeners(){if(typeof this.client>"u")throw new Error("Sign Client is not initialized");this.client.on("session_ping",t=>{this.events.emit("session_ping",t)}),this.client.on("session_event",t=>{const{params:e}=t,{event:s}=e;if(s.name==="accountsChanged"){const i=s.data;i&&q(i)&&this.events.emit("accountsChanged",i.map(vt))}else if(s.name==="chainChanged"){const i=e.chainId,n=e.event.data,a=P(i),c=E(i)!==E(n)?`${a}:${E(n)}`:i;this.onChainChanged(c)}else this.events.emit(s.name,s.data);this.events.emit("session_event",t)}),this.client.on("session_update",({topic:t,params:e})=>{var s;const{namespaces:i}=e,n=(s=this.client)==null?void 0:s.session.get(t);this.session=A(w({},n),{namespaces:i}),this.onSessionUpdate(),this.events.emit("session_update",{topic:t,params:e})}),this.client.on("session_delete",async t=>{await this.cleanup(),this.events.emit("session_delete",t),this.events.emit("disconnect",A(w({},O("USER_DISCONNECTED")),{data:t.topic}))}),this.on(p.DEFAULT_CHAIN_CHANGED,t=>{this.onChainChanged(t,!0)})}getProvider(t){return this.rpcProviders[t]||this.rpcProviders[f]}onSessionUpdate(){Object.keys(this.rpcProviders).forEach(t=>{var e;this.getProvider(t).updateNamespace((e=this.session)==null?void 0:e.namespaces[t])})}setNamespaces(t){const{namespaces:e,optionalNamespaces:s,sessionProperties:i}=t;e&&Object.keys(e).length&&(this.namespaces=e),s&&Object.keys(s).length&&(this.optionalNamespaces=s),this.sessionProperties=i,this.persist("namespaces",e),this.persist("optionalNamespaces",s)}validateChain(t){const[e,s]=t?.split(":")||["",""];if(!this.namespaces||!Object.keys(this.namespaces).length)return[e,s];if(e&&!Object.keys(this.namespaces||{}).map(a=>P(a)).includes(e))throw new Error(`Namespace '${e}' is not configured. Please call connect() first with namespace config.`);if(e&&s)return[e,s];const i=P(Object.keys(this.namespaces)[0]),n=this.rpcProviders[i].getDefaultChain();return[i,n]}async requestAccounts(){const[t]=this.validateChain();return await this.getProvider(t).requestAccounts()}onChainChanged(t,e=!1){if(!this.namespaces)return;const[s,i]=this.validateChain(t);i&&(e||this.getProvider(s).setDefaultChain(i),this.namespaces[s]?this.namespaces[s].defaultChain=i:this.namespaces[`${s}:${i}`]?this.namespaces[`${s}:${i}`].defaultChain=i:this.namespaces[`${s}:${i}`]={defaultChain:i},this.persist("namespaces",this.namespaces),this.events.emit("chainChanged",i))}onConnect(){this.createProviders(),this.events.emit("connect",{session:this.session})}async cleanup(){this.session=void 0,this.namespaces=void 0,this.optionalNamespaces=void 0,this.sessionProperties=void 0,this.persist("namespaces",void 0),this.persist("optionalNamespaces",void 0),this.persist("sessionProperties",void 0),await this.cleanupPendingPairings({deletePairings:!0})}persist(t,e){this.client.core.storage.setItem(`${S}/${t}`,e)}async getFromStore(t){return await this.client.core.storage.getItem(`${S}/${t}`)}}const Tt=C;export{Tt as UniversalProvider,C as default};
//# sourceMappingURL=index.es.js.map
